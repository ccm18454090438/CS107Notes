## Lecture 14 堆管理

主要是malloc， realloc， free等内存分配操作的工作原理


### 目前为止的堆

当一个程序运行时：

1. 创建一个进程 
2. 设置对应的地址空间或地址段
3. 读取文件加载指令， 加载所需数据，按照需求加载对应库。  
4. 设置堆栈， 保留堆栈段，初始化%rsp， 调用main函数。  
5. 在C中调用malloc，使用时初始化自身，请求操作系统提供较大的内存空间， 用于分配给对应请求。  

堆栈内存在函数调用结束后消失，有gcc在编译时自动管理。  

其实堆内存第一直有的， 知道我们不再调用它时，申请和释放的操作主要由C标准库进行管理。  对应函数前面有说，  

这节主要是说堆是怎样进行管理的。  


### 什么是堆分配器

堆分配器就是一组函数， 
初始化时，向堆分配器分配一块较大的连续内存块的起始地址和大小。  

关于堆分配器的实际操作中的过程图见课件，太多了不上传了。   


### 堆分配器的要求和目标

堆分配器必须满足：
1. 处理分配和释放任何序列的请求
2. 跟踪记录那些内存是已经分配的，那些是可用的，  
3. 做出决定用那块内存来满足分配请求
4. 即刻做出回应，不能拖延。  


所以：  
1.   堆分配器不能预判请求的顺序，更不能保证内个分配请求都伴随着一个匹配的空间。
2.   堆分配器将内存区域标记为已分配或可用。它能记住哪个是正确地为客户机提供的内存。
3.   堆分配器可以选择使用那一部分内存来满足分配请求， 当然这要考虑很多因素。  
4.   堆分配器必须对每条分配请求立即做出回应，不能出于任何原因延迟。  

同时：  返回的地址是8字节对齐的地址，（是8的倍数）



#### 堆分配器目标

1.  最大化吞吐量： 也就是单位时间内能够满足的请求数，
2.  最大化内存利用效率： 如何利用有限的堆内存满足请求


#### 利用率

低利用率的原因主要是碎片化，当没有使用是内存无法满足内存请求时，或者由于前面的内存的申请释放导致的内存碎片化，也就是说内存碎片的聚合足够满足请求，而没有单独的一块能够满足的现象。  

所以我们期望利用率尽量高，或者说，我们期望最大地址尽量低。  


而且由于我们已经完成了分噢诶，所以我们不能再去动这些地址，所以我们不能对碎片进行移动拼接。  


#### 碎片化

内部碎片：  
分配块大于所需块，收最小快的大小影响。  

外部碎片：  
没有一块足够大小的内存块来满足分配，即使有足够的聚合内存。  



#### 矛盾的堆分配器目标

再看一下堆分配器目标：  
1.  最大化吞吐量： 也就是单位时间内能够满足的请求数，
2.  最大化内存利用效率： 如何利用有限的堆内存满足请求


这显然是两个矛盾的目标。   
如果想更好的给予合适的内存块，就必然要消耗更多的时间。  

所以吨分配器要协调好两个目标的关系，寻找合适的平衡点，兼顾两个要求。  


除了上面说到的这些，还有一些其他的目标或要求： 
1. 健壮性问题。 （能够处理错误）
2. 维护问题 。（是否易于维护）。  
等等。。。。


### 方法0： 通气分配器

如果仅仅考虑吞吐量的问题，完全忽视利用率的问题，那应该怎么做呢？？？  

#### 通气分配器性能：

1. 最高吞吐量，超快回复请求。  
2. 超低利用率。从不复用内存、  


通气分配器在使用的过程中对于分配请求，只需要找到下一个可用内存地址，对于空请求则什么也不不做， 对于free请求也什么也不做，每个内存块只使用一次，不用释放，  

具体的使用流程图见课件。   

#### 摘要
通气分配器是一种比较极端的分配方式， 只考虑吞吐量，完全忽略利用率， 不太可行，  

我们要想一想：  
1.  我们怎么跟踪记录free掉的内存块， 
2.  怎么选择合适的内存块进行分配呢？
3.  分配之后，如何处理剩余的内存空闲部分。 



## 方法1： 隐式自由列表分配法

为了能够提高利用率，我们需要跟踪记录那些块是空闲的，那些是已经使用的，    
所以， 我们在每一个内存块前面添加一个头，用来记录可用空间活泼已用大小等这些信息，    
当我们要进行分配时，直接查看空闲块，然后进行分配并更新空闲块的头。   这样就好似我们有了一个隐藏的跟踪内存分配情况的列表  

头的大小至少应该是八字节。后面会说为什么



怎么用八字节表示使用情况？？  

因为内存地址是八的倍数。    
所以其实8字节低三位是用不到的，所以我可以利用低三位来表示是否空闲。  
（例如最后一位1 使用，0 空闲）

#### 隐式空闲列表分配器

怎么选择空闲块用于分配？  

1. 第一次匹配： 从头检索列表然后选择合适的的空闲块， 
2. 下一次匹配： 不必从头开始，从上次匹配停止出继续。  
3. 最佳匹配： 检索每一块，寻找适合的最小的块。  


#### 总结

这种方式：对于所有内存块都配上了头，用于记录大小和使用情况， 相当于我们用列表将内存块连接了起来，    

这样一来：  提高了利用率，降低了吞吐量。  增加了分配器的设计复杂性。   

#### 边缘情况

对于边缘情况怎么处理呢？？

1.  将其连接到前面的内存块 ，作为内部碎片
2.  单独设立空闲块，大小为0字节，作为外部碎片。  


#### 回顾几个问题

1. 如何跟踪空闲块？？
2. 如何选择合适的内存块满足请求
3. 重新分配后如何处理先前块
4. 如何处理示释放请求



#### 聚合问题

当两个空闲块挨着的时候，要不要进行聚合处理？？？

这是显式分配器要考虑的问题，下面会有。  


#### 优化
1. 能不能不搜索所有快就获得自由块
2. 可否合并相邻自由块以获得较大的自由块。  
3. 可否在重新分配避免每次都移动数据。  



### 显式自由列表分配器

#### 显式分配器

修改每个头，添加一个指向上一个空闲内存块的指针，和一个指向下一个内存块的指针，   
不过。这样是低效的，我们只需要在自由快之间跳转，  
由于空闲块的空间是自由的，我们就在空闲块的的有效空间的前16字节存储上述指针。  

所以这就要求每个内存块必须足够大。   


这是建立在隐式基础上的。   
提高了吞吐量， 同时也带来了一些设计上的开销。  以及一些内部碎片。 

1. 当我们分配一个内存块时， 用链表找到合适的内存块， 然后更新头和链表反映分配大小个表明已被分配。  
2. 当释放一个块时，就更新链表。  



所以：  显式分配器的机制就是：    
 .  包含大小和分配状态的8字节头    
 .  自由块的有效空间的前16字节存放指针。指向上一个自由块和下一个自由块。  
 .  当然这也表明其实显式的链表是可以进行排序的。 也就是可以对自由块排序。  

#### 聚合

我们有足够的内存空间满足分配请求，不过我们的空间呗分割成了若干块。    
怎么办？？？   
聚合  

所以聚合就是合并相邻自由块

怎么操作？？？   
在释放某块时，合并其右侧相邻的自由块即可。  

#### 就地重新分配

情况：  
1. 大小增大，当前块的后面有填充，且空间足够，直接用。 （解释一下没什么是填充，就是位于当前块的后面0多出来的且未使用的没有被独立出来作为单独内存块的空间）
2. 大小减小，直接操作即可。   
3. 大小增大， 当前块不够大，但是相邻块是空闲的，且合并后足够大，合并，然后分配


其余的情况就不属于就地分配的情况了，就要转移数据了。  



还有就是上面的情况可以重复    
例如：  现有空间不够，加上填充也不够，不过就加上相邻自由块就够了。   


还有一种更高级的是： 带有大小桶的显示列表。  只是简单了解即可

本节的好多内容课件上都有具体的流程实例，值得一看。  

### OK  本节结束   


## Lecture 15 优化

了解如何优化代码提高运行效率和速度，   
了解GCC可执行的优化  

###  什么是优化

优化是使程序在时间个空间上更快更高效的完成任务。  
优化是非常必要的。  

一般优化工作概括为： 

1. 如果很少做某些事情，而且只在少量输入上做，那么就用最容易进行编码，理解，调试的方式，  
2. 如果做的事比较多，或者是消耗资源很多，就要使 Big-O（复杂的） 合理
3. GCC优化
4. 显式优化



### GCC优化

gcc编译器有两个优化级别：

1.  gcc–O0//大部分只是C的直译
2.  gcc–O2//启用几乎所有合理的优化
还有其他自定义和更具激进性的优化级别
1. -O3//比O2更具攻击性，以大小换速度
2. -Os//优化大小
3. -Ofast//无视标准遵从性（！！）

更多见链接[gcc优化](https://gcc.gnu.org/onlinedocs/gcc/Optimize-Options.html
)


示例： 矩阵乘法

源代码：

    void mmm(double a[][DIM], double b[][DIM], double c[][DIM], int n) {
        for (int i = 0; i < n; i++) {
            for (int j = 0; j < n; j++) {
                for (int k = 0; k < n; k++) {
                    c[i][j] += a[i][k] * b[k][j];
                }
            }
        }
    }


-O0的编译方式

    ./mult		// -O0 (no optimization)
    matrix multiply  25^2: cycles   0.43M 
    matrix multiply  50^2: cycles   3.02M 
    matrix multiply 100^2: cycles  24.82M 


-O2的优化方式：
    
    ./mult_opt	// -O2 (with optimization)
    matrix multiply  25^2: cycles   0.13M (opt)
    matrix multiply  50^2: cycles   0.66M (opt)
    matrix multiply 100^2: cycles   5.55M (opt)



#### 常量折叠

如果可能，常量折叠在编译时预先计算常量  

例如：

    int seconds = 60 * 60 * 24 * n_days;


再看一个示例：


源代码是：

        int fold(int param) {
            char arr[5];
            int a = 0x107;
            int b = a * sizeof(arr);
            int c = sqrt(2.0);
            return a * param + (a + 0x15 / c + strlen("Hello") * b - 0x37) / 4;
        }



-O0的结果是:
    
    0000000000400626 <fold>:
      400626:	55                   	push   %rbp
      400627:	53                   	push   %rbx
      400628:	48 83 ec 08          	sub    $0x8,%rsp
      40062c:	89 fd                	mov    %edi,%ebp
      40062e:	f2 0f 10 05 da 00 00 	movsd  0xda(%rip),%xmm0
      400635:	00 
      400636:	e8 d5 fe ff ff       	callq  400510 <sqrt@plt>
      40063b:	f2 0f 2c c8          	cvttsd2si %xmm0,%ecx
      40063f:	69 ed 07 01 00 00    	imul   $0x107,%ebp,%ebp
      400645:	b8 15 00 00 00       	mov    $0x15,%eax
      40064a:	99                   	cltd   
      40064b:	f7 f9                	idiv   %ecx
      40064d:	8d 98 07 01 00 00    	lea    0x107(%rax),%ebx
      400653:	bf 04 07 40 00       	mov    $0x400704,%edi
      400658:	e8 93 fe ff ff       	callq  4004f0 <strlen@plt>
      40065d:	48 69 c0 23 05 00 00 	imul   $0x523,%rax,%rax
      400664:	48 63 db             	movslq %ebx,%rbx
      400667:	48 8d 44 18 c9       	lea    -0x37(%rax,%rbx,1),%rax
      40066c:	48 c1 e8 02          	shr    $0x2,%rax
      400670:	01 e8                	add    %ebp,%eax
      400672:	48 83 c4 08          	add    $0x8,%rsp
      400676:	5b                   	pop    %rbx
      400677:	5d                   	pop    %rbp
      400678:	c3                   	retq 



而 -O2的结果是:

    00000000004004f0 <fold>:
      4004f0:	69 c7 07 01 00 00    	imul   $0x107,%edi,%eax
      4004f6:	05 a5 06 00 00       	add    $0x6a5,%eax
      4004fb:	c3                   	retq   
      4004fc:	0f 1f 40 00          	nopl   0x0(%rax)



#### 公共子表达式消除

公共子表达式消除通过一次执行并保存结果防止对同一表达式的重复计算.  

例如

     int a = (param2 + 0x107);
     int b = param1 * (param2 + 0x107) + a;
     return a * (param2 + 0x107) + b * (param2 + 0x107);
    


这种优化在-O0d情况下也有。  

上述代码编译后是

    00000000004004f0 <subexp>:
      4004f0:	81 c6 07 01 00 00    	add    $0x107,%esi
      4004f6:	0f af fe             	imul   %esi,%edi
      4004f9:	8d 04 77             	lea    (%rdi,%rsi,2),%eax
      4004fc:	0f af c6             	imul   %esi,%eax
      4004ff:	c3                   	retq 


#### 死代码消除

死代码消除将删除不起作用的代码  

示例：
源代码：  


    if (param1 < param2 && param1 > param2) {
        printf("This test can never be true!\n");
    }
    
    // Empty for loop
    for (int i = 0; i < 1000; i++);
    
    // If/else that does the same operation in both cases
    if (param1 == param2) {
        param1++;
    } else {
        param1++;
    }
    
    // If/else that more trickily does the same operation in both cases
    if (param1 == 0) {
        return 0;
    } else {
        return param1;
    }


-O0的结果的

    00000000004004d6 <dead_code>:
      4004d6:	b8 00 00 00 00       	mov    $0x0,%eax
      4004db:	eb 03                	jmp    4004e0 <dead_code+0xa>
      4004dd:	83 c0 01             	add    $0x1,%eax
      4004e0:	3d e7 03 00 00       	cmp    $0x3e7,%eax
      4004e5:	7e f6                	jle    4004dd <dead_code+0x7>
      4004e7:	39 f7                	cmp    %esi,%edi
      4004e9:	75 05                	jne    4004f0 <dead_code+0x1a>
      4004eb:	8d 47 01             	lea    0x1(%rdi),%eax
      4004ee:	eb 03                	jmp    4004f3 <dead_code+0x1d>
      4004f0:	8d 47 01             	lea    0x1(%rdi),%eax
      4004f3:	f3 c3                	repz retq



-O2的结果是：

    00000000004004f0 <dead_code>:
      4004f0: 8d 47 01              lea    0x1(%rdi),%eax
      4004f3: c3                    retq   
      4004f4: 66 2e 0f 1f 84 00 00  nopw   %cs:0x0(%rax,%rax,1)
      4004fb: 00 00 00 
      4004fe: 66 90                 xchg   %ax,%ax

#### 强度折减

强度折减将“除法”更改为“乘”，将“乘”更改为“加/移”，并将“取模”改为“与” 以避免使用耗费许多周期的指令（乘和除）。


#### 代码运动

如果可以的话代码运动会将代码移出循环

    
    for (int i = 0; i < n; i++) {
      sum += arr[i] + foo * (bar + 3); 
    }

公共子表达式消除处理多次出现的代码， 不过在这里，虽然没有多次出现，不过每次循环都要计算。  

#### 尾部递归

尾部递归是GCC识别递归模式的一个例子，这种模式可以更有效地迭代实现。

代码示例是：  

    long factorial(int n) {
      if (n <= 1) {
          return 1;
      }
      else return n * factorial(n - 1);
    }



#### 循环展开

循环展开：    
每次实际的循环迭代都要做n个循环迭代的工作，这样我们就不用每次都做循环开销（测试和跳转），而只会在第n次循环迭代中产生开销。


代码示例：  
    
    for (int i = 0; i <= n - 4; i += 4) { 
    	sum += arr[i];
    	sum += arr[i + 1];
    	sum += arr[i + 2];
    	sum += arr[i + 3];
    } // after the loop handle any leftovers



### GCC优化的局限性

GCC不能优化所有的东西， 人会比GCC懂的更多


代码：  

    int char_sum(char *s) {
        int sum = 0;
        for (size_t i = 0; i < strlen(s); i++) {
            sum += s[i];
        }
        return sum;
    }


其中的有哪些地方是可优化的？？

strlen  每次循环都会调用  ！！ 

怎么办？？   代码运动会将其拉出循环。  




代码2：   

    void lower1(char *s) {
        for (size_t i = 0; i < strlen(s); i++) {
            if (s[i] >= 'A' && s[i] <= 'Z') {
                s[i] -= ('A' - 'a');
            }
        }
    }


问题也是在strlen。  
不过s是变化的， GCC不确定是不是一个常数，  不过我们自己知道长度是不会变化的。   


###  缓存

处理器性能不是限制程序性能的唯一标准，  内存访问更是一个限制。  

内存是以级别的形式出现的，  以读取熟读为标准，从非常快(寄存器)到非常慢
(硬盘)  。   
其实， 随着数据的使用越来越频繁，它在内存中存在的位置的读取速度也越来越快。  

**缓存取决于位置**  

时间位置：  对于同一数据的重复访问往往集中在同一时间段。  
空间位置：  相关的数据趋向于在空间内临近。 （就是说刚访问过的数据旁边的数据接下来更可能呗访问）  




#### OK 本节内容结束


## 后面的课程就是关于下一步课程学习的介绍，这些内容在 Lecture 16 。再往后就是关于考试的内容了。想看的自己去看课件就好了。  前面有链接，试题的话[在这里](https://web.stanford.edu/class/archive/cs/cs107/cs107.1202/exams/final/FinalExamQuestions.pdf) 
