## Lecture 13 函数调用和运行时的堆栈

### 再看%rip

%rip 是一个特殊的寄存器，存储下一条要执行的命令。  



示例： 

    void loop() {
        int i = 0;
        while (i < 100) {
            i++;
        }
    }

对应的汇编： 

    0x400570 <+0>:  b8 00 00 00 00 mov $0x0,%eax
    0x400575 <+5>:  eb 03          jmp 0x40057a <loop+10>
    0x400577 <+7>:  83 c0 01       add $0x1,%eax
    0x40057a <+10>: 83 f8 63       cmp $0x63,%eax
    0x40057d <+13>: 73 f8          jle 0x400577 <loop+7>
    0x40057f <+15>: f3 c3          repz retq 


其中从左往右第二列，也就是<+0> 所在列，  

该列存储的是没条指令的偏移量，（从0开始的偏移量），  单位是字节，  


偏移量右边的一列是机器代码。  不同的指令的字节长度是不同的。


还有一些地方要注意，以第二行为例：  

    0x400575 <+5>:  eb 03          jmp 0x40057a <loop+10>


03 ， 说的是相对于%rip要跳转的指令字节数， 当然，如果没有跳跃就是按顺序接着往下走。  


    0x40057d <+13>: 73 f8          jle 0x400577 <loop+7>

这里的f8也是说的要跳转的字节数，  不过其实这里是-8，因为是补码。  

这里也是，如果没有跳跃， 就继续按顺序走。  



#### 还有一点

机器指令是存在于主内存中的， %rip只是存储的地址，


### 函数调用

需要在汇编中进行函数调用， 
1.   必须将%rip调整到被调用函数的指令，然后在函数中按照顺序继续执行指令。
2.   还要进行参数传递， 返回值接收的问题
3.   同时还需要满足被调用函数在堆栈上的空间要求

 汇编怎样与堆栈进行交互呢？？？ 
#### 堆栈

%rsp 是一个特殊的寄存器，存储当前堆栈顶部的地址，


关键在于：     
%rsp在函数调用前和函数返回后，必须指向同一个位置， 因为函数调用结束后，堆栈上对应的地址空间会别释放，


##### push

push 将指定来源的数据推送到堆栈顶部，同时调整%rsp



    pushq S

对应操作： 

    R[%rsp] ⟵ R[%rsp] – 8;
    M[R[%rsp]] ⟵ S 

对应到汇编就是

     subq $8, %rsp
     movq  S, (%rsp) 


##### pop 

pop指令将栈顶的数据弹出，并存储到指定目的地， 并调整%rsp。  

当然骂他不会对清出来的空间+进行清空，数据还是那些，只不过是可以再次使用，下次可以直接覆盖。  

    popq D

对应操作

    D ⟵ M[R[%rsp]]
    R[%rsp] ⟵ R[%rsp] + 8;
    


对应汇编：  

    movq (%rsp), D
    addq $8, %rsp



#### 传递控制


由于%rip指向下一个要执行的指令，  
想要调用函数，必须要存储下一个调用方（例如：main函数）的指令后继续。 

所以： 
1. 将下一个要执行的指令存放到堆栈上，
2. 待调用结束后， 将值放回%rip继续执行。  


##### 调用和返回

call指令

call指令将跟在call指令后面的指令地址推送到堆栈上，并将%rip设置为指向指定函数指令的开头。

    call Label		
    call *Operand


ret指令  

ret指令从堆栈中取出指令并将其存储到%rip中， 这里说的是指令地址，不要和返回值混淆。  


#### 传递数据

传递和返回  。。  

计算机有专门的寄存器存储参数和返回值，

要调用函数，我们必须将传递的任何参数放入正确的寄存器中。

（按顺序为%rdi、%rsi、%rdx、%rcx、%r8、%r9） 

超出前6个参数的参数将被放入堆栈中

如果函数有返回值的话，就在调用结束后，访问%rax。  


#### 本地存储

正常来说，局部变量是存储在堆栈中的，  
但是，我们经常看到局部变量直接存储在寄存器中，而不是像预期的那样存储在堆栈中。这是出于优化的原因。

再有：  

本地数据必须在内存中有三个常见原因：

1. 我们的寄存器用完了
2. 在它上面使用了'&'运算符，所以我们必须为它生成一个地址
3. 它们是数组或结构（需要使用地址算术）


看一个示例：  


    long caller() {
        long arg1 = 534;
        long arg2 = 1057;
        long sum = swap_add(&arg1, &arg2);
        ...
    }
    


        caller:
        subq $0x10, %rsp      // 16 bytes for stack frame
        movq $0x216, (%rsp)   // store 534 in arg1
        movq $0x421, 8(%rsp)  // store 1057 in arg2
        leaq 8(%rsp), %rsi    // compute &arg2 as second arg
        movq %rsp, %rdi       // compute &arg1 as first arg
        call swap_add         // call swap_add(&arg1, &arg2)
    


### 寄存器限制


需要注意的是：  所有程序和函数只有一个寄存器副本。即寄存器是唯一的。 


那么如果： 如果funcA在寄存器%r10中建立一个值，并在中间调用funcB，这也有修改%r10的指令，怎么办？funcA的值将被覆盖！

怎么办呢:   

制定一些“规则”，调用者和被调用者在使用寄存器时必须遵守这些规则，这样他们就不会互相干扰。

这些规则定义了两种类型的寄存器：调用者拥有和被调用者拥有，这样就不会出现对同一个寄存器的重复使用。  

调用者和被调用者是相对的概念，一个函数既可以是调用者，也可以是被调用者。  



####  对于调用方拥有是寄存器

被调用方必须保存现有值并在使用完毕后还原它。

调用者可以用其存储值，并假设它在函数调用中不被修改。



对于被调用方拥有的寄存器


####  对于被调用方不需要保存现有值。

调用方的前面存储的值可能被被调用方覆盖！调用方可以考虑在调用函数之前将值保存在其他地方。




### 第一个汇编程序


看一下刚说到汇编是的第一个汇编程序

    int sum_array(int arr[], int nelems) {
       int sum = 0;
       for (int i = 0; i < nelems; i++) {
          sum += arr[i];
       }
       return sum;
    }


    
    00000000004005b6 <sum_array>:
      4005b6:    ba 00 00 00 00       mov    $0x0,%edx
      4005bb:    b8 00 00 00 00       mov    $0x0,%eax
      4005c0:    eb 09                jmp    4005cb <sum_array+0x15>
      4005c2:    48 63 ca             movslq %edx,%rcx
      4005c5:    03 04 8f             add    (%rdi,%rcx,4),%eax
      4005c8:    83 c2 01             add    $0x1,%edx
      4005cb:    39 f2                cmp    %esi,%edx
      4005cd:    7c f3                jl     4005c2 <sum_array+0xc>
      4005cf:    f3 c3                repz retq 



### 优化

nop指令：

nop/nopl指令的意思是说禁止操作，  
就是什么都不做

它的目的是使函数的地址边界对齐，地址边界正好是8的倍数。  


    mov %ebx,%ebx

在寄存器上的mov指令（寄存器作为目标）会将剩余位清零。  


    xor %ebx,%ebx
将前32位清零。 


更多的关于优化内容见课件及课程网站的上的资料、  




