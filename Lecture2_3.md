

## Lecture 2

### 本节课程计划
1. 比特与字节
2. 十六进制
3. 整数表示法
4. 无符号整数
5. 有符号整数
6. 溢流
7. 转换类型和合并类型


### 比特和字节

1. 了解十进制和二进制
2. 计算机是以0 1 为单位的，计算机上所有的数据，文件都是二进制表示的  一个二进制为为一个比特位 。一个字节=八个比特位
3. 熟练进行十进制和二进制之间的转换（转换方法不止一种，看自己）
4. 了解基数的概念  二进制的基数是2，十进制的基数是10
5. 一个字节所能表示的数  最大为 255  最小为0
6. 乘以基数和除以基数的运算

### 十六进制
1. 我们在处理32位，64位的数据是   为了方便要用到，当然好多地方
2. 了解十六进制的基数是16  以及各数对应的数字或字母
3. 十进制  二进制  十六进制中 对于0-15 之间的对应关系
4. 对于各进制的数我们为了便于区分   二进制前有0b    十进制省略   十六进制用0x
5. 熟练进行十六进制和二进制和十进制之间的转换

### 整数表示法
整数有分有符号和无符号以及浮点数
本节先了解一下计算机上的32位和64位，以及在这两种环境下各类型的数据分别占多少空间
#### 32位
| C Declaration |Size (Bytes)   |
|:------------- |------------:  |
| int           |4 |
| double        |8 |
| float         |4 |
| char          |1 |
| char *        |4 |
| short         |2 |
| long          |4 |

#### 64位

| C Declaration |Size (Bytes)   |
|:------------- |------------:  |
| int           |4 |
| double        |8 |
| float         |4 |
| char          |1 |
| char *        |8 |
| short         |2 |
| long          |8 |

至于为什么，我把原文的翻译放在这里
> 21世纪初：大多数计算机是32位的。这意味着指针是4个字节（32位）。
32位指针存储从0到232-1的内存地址，相当于232字节的可寻址内存。这相当于4GB，这意味着32位计算机最多可以有4GB内存（RAM）！
正因为如此，计算机转换到64位。这意味着数据类型被放大了；程序中的指针现在是64位。
64位指针存储从0到264-1的内存地址，相当于264字节的可寻址内存。这相当于16EB，这意味着64位计算机最多可以有1024*1024*1024GB的内存（RAM）！

有链接，自己看就好了  ，了解即可

### 无符号整数
0或正整数
范围  0--2的n次方减一  （n为二进制位数，即位的数目）


无符号整形的表示是呈圈形的
以四位二进制表示为例
1111：15       此数加一为0

图片的话更形象   课件里面有


#### 有符号整数
简单点一个公式
一个整数的负数表示=其正整数的二进制表示取反加一

例如1：0001   
-1 ： 1111

| Decimal	| Positive	| Negative |
|:------------- |----  |----------|
| 0 | 0000	| 0000
| 1	| 0001	| 1111
| 2	| 0010	| 1110
| 3	| 0011	| 1101
| 4	| 0100	| 1100
| 5	| 0101	| 1011
| 6	| 0110	| 1010
| 7	| 0111	| 1001
| 8	| ####	| 1000

附一句  以四位二进制为例   
其表示范围(有符号整型)-8~7
理解为   -(2的(4-1)次方)--2的(4-1)次方-1
前面的4换成n  就是n位二进制所能表示的有符号整数范围


总结   有符号整数  表示
正：   直接转换就好 （原码）
负：   补码（对应正数的二进制表示反码加一）
0  全是0

这样利于进行加减运算  具体的演示 见课件


#### 溢出

溢出则“绕圈”   按照课件上图示的那样  ，这里就不上图了
例如   四位二进制有符号整数  
圈为    0~7~（-8）~（-1）~0；
端点处的0连接起来  即为圈  
其他的数据类型 例如  char   
其对应的ASC码也遵循此规则  只不过 显示的时候是其对应的字符表示

对于溢出现象 课件有更为详细的介绍以及案例，有时间的可以去了解一下



#### 转换类型和合并类型


##### 占位符
%d 有符号32位int
%u 无符号32位int
%x 16进制表示的32位int

用于在printf中表示要输出的类型  
这种占位符 还有很多种
自行搜索 因为这属于C语言的内容


提一个问题

int v = -12345;

unsigned int uv = v;

printf("v = %d, uv = %u\n", v, uv);
	
输出: "v = -12345, uv = 4294954951".
这是为什么呢


另外补充一点
在进行 无符号整型和有符号整型的大小比较时
C讲两数均转换为无符号整形进行比较

####  类型转换

有时  我们会对两个不同类型的数进行比较
此时，系统会将两数均转换为较大的类型  进而进行比较

这里说一下   我们不能将较大的数据类型转换为小的类型 ，但反之是可行的

那么 转换是怎样进行的呢  

无符号  前面补0
有符号  前面补符号位

有时候我们也会将大类型转化为小类型

此时会将数据的长度进行折断
忽视高位（左边）

这段内容课件上有配套练习题  建议去看一下



##### sizeof 运算符

该运算符接受一个变量类型，并返回其大小  单位为字节

//示例

long int_size_bytes=sizeof（int）；//4

long short_size_bytes=sizeof（short）；//2

long char_size_bytes=sizeof（char）；//1







## lecyture 3

此节主要是位运算的介绍
补充一句 计算机中所有数据等 全是用01表示

#### 先介绍一下ASC码

ASCII是从普通字符（字母、符号等）到位表示（字符）的编码

所有大写字母和所有小写字母都按顺序表示！

更具体的自行百度

#### 位运算符
有哪些： &, |, ~, ^, 

介绍

1.   & 同时为1 结果为1
2.   | 只要有一个为1 结果就是1
3.   ~ 原来是1变为0 原来是0变为1 （取反）
4.   ^  二者不同（一0一1） 结果为1 否则为0

--  学过离散数学会更好

##### 应用 见课件  
比如

如何分离某位

如何修改指定为 

如何求位的交集 并集

如何翻转 指定位或所有位

#### 左移运算符

所谓左移运算符： <<    
就是将该数在内存中的二进制表示向左移动 

用新的最高位去取代最高位 低位用0替换

例如  00110111 << 2    返回 11011100
左移简单点 ，重点是右移

#### 右移运算符  
移动很简单    但是用什么来填充移掉的位置呢
用0 ？？

0是不行的  

x=-2；//1111 1111 1111 1110

x>>=1；//0111 1111 1111 1111

printf（“%d\n”，x）；//32767！
多余的例子就不举了

OK  我们现在看解决方案

我们用符号位进行填充

例1

x=2；//0000 0000 0000 0010

x>=1；//0000 0000 0000 0001

printf（“%d\n”，x）；//1


例2

x = -2;	// 1111 1111 1111 1110

x >>= 1;		// 1111 1111 1111 1111

printf("%d\n", x);	// -1!

这样就不会找成符号错乱等问题


##### 总而言之

右移  有两种
1. 逻辑右移  用0 补充
2. 算术右移  用符号位（高阶有效位）补充

###### 一般使用场景


无符号数字使用逻辑右移进行右移。

有符号数字使用算术右移进行右移。


###### 补充 

从技术上讲，C标准并没有精确地定义有符号整数的右移是逻辑的还是算术的。

但是  几乎所有的编译器/机器都使用算术，


还有一点   1<<2+3<<4
例如上面的这种运算

要注意！！     
加法和减法的优先级高于移位！

等效为    1<<（2+3）<<4


####  其余注意点


如果你想要一个二进制位前32位全为1的长整型

long num = 1 << 32;

这样是不对的

默认情况下，1是一个int，并且不能将int移位32，因为它只有32位。必须指定希望1为long。

所以要用  

long num==1L<<32;



### OK 本课结束  

